import { 
  SmartNotification, 
  NotificationChannel, 
  Employee, 
  Call, 
  SchedulingSuggestion 
} from '@/types';
import { generateId } from './utils';
import { BrowserNotificationService } from './browser-notifications';
import { NotificationService } from './notification-service';

/**
 * Smart Notification Service
 * Sistema di notifiche intelligenti che si adattano al contesto
 */
export class SmartNotificationService {
  private static instance: SmartNotificationService;
  private notifications: SmartNotification[] = [];
  private readonly STORAGE_KEY = 'hr-smart-notifications';

  private constructor() {
    this.loadNotifications();
  }

  static getInstance(): SmartNotificationService {
    if (!SmartNotificationService.instance) {
      SmartNotificationService.instance = new SmartNotificationService();
    }
    return SmartNotificationService.instance;
  }

  /**
   * Crea notifica per call auto-schedulata
   */
  async createAutoScheduledNotification(
    call: Call, 
    employee: Employee, 
    suggestion: SchedulingSuggestion
  ): Promise<SmartNotification> {
    const notification: SmartNotification = {
      id: generateId(),
      type: 'suggestion_available',
      priority: suggestion.priority,
      title: `Call Auto-Programmata: ${employee.nome} ${employee.cognome}`,
      message: `√à stata programmata automaticamente una call per ${new Date(call.dataSchedulata).toLocaleDateString('it-IT')} basata su: ${suggestion.reasoning.slice(1, 3).join(', ')}`,
      contextData: {
        callId: call.id,
        employeeId: employee.id,
        suggestionId: suggestion.id,
        triggers: suggestion.triggers,
        confidence: suggestion.confidence
      },
      relatedEmployeeId: employee.id,
      relatedCallId: call.id,
      channels: this.getDefaultChannelsForPriority(suggestion.priority),
      status: 'pending',
      autoGenerated: true,
      createdAt: new Date().toISOString()
    };

    this.notifications.push(notification);
    await this.sendNotification(notification);
    this.saveNotifications();

    return notification;
  }

  /**
   * Crea notifica per performance in calo
   */
  async createPerformanceAlertNotification(
    employee: Employee, 
    currentScore: number, 
    previousScore?: number
  ): Promise<SmartNotification> {
    const decline = previousScore ? previousScore - currentScore : 0;
    const priority = currentScore < 4 ? 'urgent' : currentScore < 6 ? 'high' : 'medium';

    const notification: SmartNotification = {
      id: generateId(),
      type: 'performance_alert',
      priority: priority,
      title: `‚ö†Ô∏è Alert Performance: ${employee.nome} ${employee.cognome}`,
      message: `Performance score: ${currentScore}/10${decline > 0 ? ` (calo di ${decline.toFixed(1)} punti)` : ''}. ${this.getPerformanceActionMessage(currentScore)}`,
      contextData: {
        employeeId: employee.id,
        currentScore,
        previousScore,
        decline,
        department: employee.dipartimento,
        position: employee.posizione
      },
      relatedEmployeeId: employee.id,
      channels: this.getDefaultChannelsForPriority(priority),
      status: 'pending',
      autoGenerated: true,
      createdAt: new Date().toISOString()
    };

    this.notifications.push(notification);
    await this.sendNotification(notification);
    this.saveNotifications();

    return notification;
  }

  /**
   * Crea notifica per contratto in scadenza
   */
  async createContractExpiryNotification(
    employee: Employee, 
    daysUntilExpiry: number
  ): Promise<SmartNotification> {
    const priority = daysUntilExpiry <= 30 ? 'urgent' : daysUntilExpiry <= 60 ? 'high' : 'medium';
    
    const notification: SmartNotification = {
      id: generateId(),
      type: 'contract_expiry',
      priority: priority,
      title: `üìã Contratto in Scadenza: ${employee.nome} ${employee.cognome}`,
      message: `Il contratto di ${employee.nome} ${employee.cognome} scadr√† tra ${daysUntilExpiry} giorni (${new Date(employee.contractExpiryDate!).toLocaleDateString('it-IT')}). ${this.getContractActionMessage(daysUntilExpiry)}`,
      contextData: {
        employeeId: employee.id,
        daysUntilExpiry,
        contractExpiryDate: employee.contractExpiryDate,
        department: employee.dipartimento,
        position: employee.posizione
      },
      relatedEmployeeId: employee.id,
      channels: this.getDefaultChannelsForPriority(priority),
      status: 'pending',
      autoGenerated: true,
      createdAt: new Date().toISOString()
    };

    this.notifications.push(notification);
    await this.sendNotification(notification);
    this.saveNotifications();

    return notification;
  }

  /**
   * Crea notifica per call in ritardo
   */
  async createOverdueCallNotification(
    call: Call, 
    employee: Employee, 
    daysPastDue: number
  ): Promise<SmartNotification> {
    const priority = daysPastDue > 14 ? 'high' : daysPastDue > 7 ? 'medium' : 'low';
    
    const notification: SmartNotification = {
      id: generateId(),
      type: 'overdue_call',
      priority: priority,
      title: `‚è∞ Call in Ritardo: ${employee.nome} ${employee.cognome}`,
      message: `La call programmata per ${new Date(call.dataSchedulata).toLocaleDateString('it-IT')} √® in ritardo di ${daysPastDue} giorni. ${this.getOverdueActionMessage(daysPastDue)}`,
      contextData: {
        callId: call.id,
        employeeId: employee.id,
        daysPastDue,
        originalDate: call.dataSchedulata,
        department: employee.dipartimento
      },
      relatedEmployeeId: employee.id,
      relatedCallId: call.id,
      channels: this.getDefaultChannelsForPriority(priority),
      status: 'pending',
      autoGenerated: true,
      createdAt: new Date().toISOString()
    };

    this.notifications.push(notification);
    await this.sendNotification(notification);
    this.saveNotifications();

    return notification;
  }

  /**
   * Crea reminder intelligente per call
   */
  async createIntelligentCallReminder(
    call: Call, 
    employee: Employee, 
    minutesBefore: number = 60
  ): Promise<SmartNotification> {
    const callDate = new Date(call.dataSchedulata);
    const reminderTime = new Date(callDate.getTime() - (minutesBefore * 60 * 1000));
    
    // Personalizza il messaggio basandoti sul contesto del dipendente
    let contextualMessage = '';
    if (employee.riskLevel === 'high') {
      contextualMessage = ' Attenzione: dipendente ad alto rischio.';
    } else if (employee.lastCallRating && employee.lastCallRating < 3) {
      contextualMessage = ' Nota: ultima call con rating basso, preparare follow-up.';
    } else if (employee.performanceScore && employee.performanceScore < 6) {
      contextualMessage = ' Nota: performance sotto la media, considerare supporto aggiuntivo.';
    }

    const notification: SmartNotification = {
      id: generateId(),
      type: 'call_reminder',
      priority: 'medium',
      title: `üìû Promemoria Call: ${employee.nome} ${employee.cognome}`,
      message: `Call programmata per ${callDate.toLocaleDateString('it-IT')} alle ${callDate.toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' })}.${contextualMessage}`,
      contextData: {
        callId: call.id,
        employeeId: employee.id,
        callDate: call.dataSchedulata,
        minutesBefore,
        employeeRisk: employee.riskLevel,
        lastRating: employee.lastCallRating,
        performanceScore: employee.performanceScore,
        callNotes: call.note
      },
      relatedEmployeeId: employee.id,
      relatedCallId: call.id,
      channels: [
        { type: 'in_app', enabled: true },
        { type: 'email', enabled: true },
        { type: 'push', enabled: true }
      ],
      scheduledAt: reminderTime.toISOString(),
      status: 'pending',
      autoGenerated: true,
      createdAt: new Date().toISOString()
    };

    this.notifications.push(notification);
    
    // Schedule the notification
    this.scheduleNotification(notification, reminderTime);
    this.saveNotifications();

    return notification;
  }

  /**
   * Invia una notifica attraverso i canali appropriati
   */
  private async sendNotification(notification: SmartNotification): Promise<void> {
    try {
      const enabledChannels = notification.channels.filter(c => c.enabled);
      
      for (const channel of enabledChannels) {
        switch (channel.type) {
          case 'in_app':
            await this.sendInAppNotification(notification);
            break;
          case 'push':
            await this.sendPushNotification(notification);
            break;
          case 'email':
            await this.sendEmailNotification(notification);
            break;
          case 'sms':
            await this.sendSmsNotification(notification);
            break;
        }
      }

      notification.sentAt = new Date().toISOString();
      notification.status = 'sent';
    } catch (error) {
      console.error('Failed to send smart notification:', error);
      notification.status = 'failed';
    }
  }

  /**
   * Invia notifica in-app
   */
  private async sendInAppNotification(notification: SmartNotification): Promise<void> {
    // Integrate with existing toast system
    const { toast } = await import('sonner');
    
    const priorityConfig = {
      urgent: { duration: 10000, style: 'destructive' },
      high: { duration: 8000, style: 'default' },
      medium: { duration: 6000, style: 'default' },
      low: { duration: 4000, style: 'default' }
    };

    const config = priorityConfig[notification.priority];
    
    toast(notification.title, {
      description: notification.message,
      duration: config.duration,
      action: notification.relatedCallId ? {
        label: 'Visualizza',
        onClick: () => {
          window.location.href = `/calls?highlight=${notification.relatedCallId}`;
        }
      } : undefined
    });
  }

  /**
   * Invia notifica push
   */
  private async sendPushNotification(notification: SmartNotification): Promise<void> {
    const browserNotificationService = BrowserNotificationService.getInstance();
    
    if (browserNotificationService.hasPermission()) {
      await browserNotificationService.showNotification(notification.title, {
        body: notification.message,
        tag: notification.id,
        data: notification.contextData,
        requireInteraction: notification.priority === 'urgent'
      });
    }
  }

  /**
   * Invia notifica email
   */
  private async sendEmailNotification(notification: SmartNotification): Promise<void> {
    // Integrate with existing email service
    try {
      await NotificationService.sendEmail({
        to: 'admin@company.com', // Should be configurable
        subject: notification.title,
        html: this.generateEmailTemplate(notification),
        priority: notification.priority
      });
    } catch (error) {
      console.error('Failed to send email notification:', error);
    }
  }

  /**
   * Invia notifica SMS
   */
  private async sendSmsNotification(notification: SmartNotification): Promise<void> {
    // Integrate with existing SMS service
    try {
      await NotificationService.sendSMS(
        '+1234567890', // Should be configurable
        `${notification.title}: ${notification.message}`
      );
    } catch (error) {
      console.error('Failed to send SMS notification:', error);
    }
  }

  /**
   * Programma una notifica per un momento futuro
   */
  private scheduleNotification(notification: SmartNotification, scheduledTime: Date): void {
    const now = new Date();
    const delay = scheduledTime.getTime() - now.getTime();
    
    if (delay > 0) {
      setTimeout(async () => {
        if (notification.status === 'pending') {
          await this.sendNotification(notification);
          this.saveNotifications();
        }
      }, delay);
    }
  }

  /**
   * Ottieni canali predefiniti basati sulla priorit√†
   */
  private getDefaultChannelsForPriority(priority: string): NotificationChannel[] {
    const baseChannels: NotificationChannel[] = [
      { type: 'in_app', enabled: true }
    ];

    switch (priority) {
      case 'urgent':
        return [
          ...baseChannels,
          { type: 'email', enabled: true },
          { type: 'sms', enabled: true },
          { type: 'push', enabled: true }
        ];
      case 'high':
        return [
          ...baseChannels,
          { type: 'email', enabled: true },
          { type: 'push', enabled: true }
        ];
      case 'medium':
        return [
          ...baseChannels,
          { type: 'push', enabled: true }
        ];
      case 'low':
      default:
        return baseChannels;
    }
  }

  /**
   * Genera messaggio d'azione per performance
   */
  private getPerformanceActionMessage(score: number): string {
    if (score < 4) return 'Azione immediata richiesta - considerare piano di miglioramento';
    if (score < 6) return 'Monitoraggio ravvicinato consigliato';
    if (score < 7) return 'Supporto aggiuntivo potrebbe essere utile';
    return 'Performance nella norma';
  }

  /**
   * Genera messaggio d'azione per contratto
   */
  private getContractActionMessage(days: number): string {
    if (days <= 30) return 'Avviare immediatamente processo di rinnovo';
    if (days <= 60) return 'Programmare discussione per rinnovo contrattuale';
    return 'Monitorare e preparare documentazione per rinnovo';
  }

  /**
   * Genera messaggio d'azione per call in ritardo
   */
  private getOverdueActionMessage(days: number): string {
    if (days > 14) return 'Riprogrammare immediatamente';
    if (days > 7) return 'Contattare per riprogrammare';
    return 'Riprogrammare appena possibile';
  }

  /**
   * Genera template email personalizzato
   */
  private generateEmailTemplate(notification: SmartNotification): string {
    const priorityColors = {
      urgent: '#ef4444',
      high: '#f97316',
      medium: '#3b82f6',
      low: '#6b7280'
    };

    const priorityIcons = {
      urgent: 'üö®',
      high: '‚ö†Ô∏è',
      medium: 'üìä',
      low: 'üìù'
    };

    const color = priorityColors[notification.priority];
    const icon = priorityIcons[notification.priority];

    return `
    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
      <div style="background: ${color}; color: white; padding: 20px; border-radius: 8px 8px 0 0;">
        <h1 style="margin: 0; font-size: 24px;">
          ${icon} ${notification.title}
        </h1>
      </div>
      
      <div style="background: #f8f9fa; padding: 20px; border-radius: 0 0 8px 8px;">
        <p style="font-size: 16px; line-height: 1.5; margin-bottom: 20px;">
          ${notification.message}
        </p>
        
        ${notification.contextData ? `
        <div style="background: white; padding: 15px; border-radius: 4px; margin-bottom: 20px;">
          <h3 style="margin-top: 0; color: #374151;">Dettagli:</h3>
          <ul style="margin: 0; padding-left: 20px;">
            ${Object.entries(notification.contextData)
              .filter(([key, value]) => value && !['callId', 'employeeId'].includes(key))
              .map(([key, value]) => `<li><strong>${key}:</strong> ${value}</li>`)
              .join('')}
          </ul>
        </div>
        ` : ''}
        
        <div style="text-align: center; margin-top: 30px;">
          <a href="http://localhost:3006/calls${notification.relatedCallId ? `?highlight=${notification.relatedCallId}` : ''}" 
             style="background: ${color}; color: white; padding: 12px 24px; text-decoration: none; border-radius: 4px; display: inline-block;">
            Visualizza nell'app
          </a>
        </div>
      </div>
      
      <div style="text-align: center; margin-top: 20px; color: #6b7280; font-size: 12px;">
        HR Call Tracker - Sistema di Notifiche Intelligenti
      </div>
    </div>
    `;
  }

  // Public API Methods

  /**
   * Crea notifica personalizzata generica
   */
  async createCustomNotification(notificationData: {
    type: string;
    priority: 'urgent' | 'high' | 'medium' | 'low';
    title: string;
    message: string;
    contextData: Record<string, any>;
    targetUserId?: string;
    relatedEmployeeId?: string;
    relatedCallId?: string;
    channels: NotificationChannel[];
    scheduledAt?: string;
    autoGenerated: boolean;
  }): Promise<SmartNotification> {
    const notification: SmartNotification = {
      id: generateId(),
      type: notificationData.type as any,
      priority: notificationData.priority,
      title: notificationData.title,
      message: notificationData.message,
      contextData: notificationData.contextData,
      targetUserId: notificationData.targetUserId,
      relatedEmployeeId: notificationData.relatedEmployeeId,
      relatedCallId: notificationData.relatedCallId,
      channels: notificationData.channels,
      scheduledAt: notificationData.scheduledAt,
      status: 'pending',
      autoGenerated: notificationData.autoGenerated,
      createdAt: new Date().toISOString()
    };

    // Salva notifica
    this.notifications.unshift(notification);
    this.saveNotifications();

    // Invia su canali specificati
    await this.sendNotification(notification);

    return notification;
  }

  /**
   * Ottieni tutte le notifiche
   */
  getAllNotifications(): SmartNotification[] {
    return [...this.notifications].sort((a, b) => 
      new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
    );
  }

  /**
   * Ottieni notifiche per priorit√†
   */
  getNotificationsByPriority(priority: SmartNotification['priority']): SmartNotification[] {
    return this.notifications.filter(n => n.priority === priority);
  }

  /**
   * Marca notifica come letta
   */
  markAsRead(notificationId: string): void {
    const notification = this.notifications.find(n => n.id === notificationId);
    if (notification) {
      notification.status = 'sent';
      this.saveNotifications();
    }
  }

  /**
   * Elimina notifica
   */
  deleteNotification(notificationId: string): void {
    this.notifications = this.notifications.filter(n => n.id !== notificationId);
    this.saveNotifications();
  }

  /**
   * Pulisci notifiche vecchie (oltre 30 giorni)
   */
  cleanupOldNotifications(): void {
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

    this.notifications = this.notifications.filter(n => 
      new Date(n.createdAt) > thirtyDaysAgo
    );
    
    this.saveNotifications();
  }

  // Storage methods
  private loadNotifications(): void {
    if (typeof window === 'undefined') return;

    try {
      const stored = localStorage.getItem(this.STORAGE_KEY);
      if (stored) {
        this.notifications = JSON.parse(stored);
      }
    } catch (error) {
      console.warn('Failed to load smart notifications:', error);
    }
  }

  private saveNotifications(): void {
    if (typeof window === 'undefined') return;
    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(this.notifications));
  }
}

// Export singleton instance
export const smartNotificationService = SmartNotificationService.getInstance();